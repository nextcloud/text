{"version":3,"file":"MarkdownContentEditor-DmNwqD-y.chunk.mjs","sources":["../node_modules/rope-sequence/dist/index.es.js","../node_modules/prosemirror-history/dist/index.js","../node_modules/@tiptap/extension-history/dist/index.js","../src/components/Editor/MarkdownContentEditor.vue"],"sourcesContent":["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\nexport default ropeSequence;\n","import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n        maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch) => {\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n            return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr)\n                dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };\n","import { Extension } from '@tiptap/core';\nimport { undo, redo, history } from '@tiptap/pm/history';\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/history\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `history` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */\nconst History = Extension.create({\n    name: 'history',\n    addOptions() {\n        return {\n            depth: 100,\n            newGroupDelay: 500,\n        };\n    },\n    addCommands() {\n        return {\n            undo: () => ({ state, dispatch }) => {\n                return undo(state, dispatch);\n            },\n            redo: () => ({ state, dispatch }) => {\n                return redo(state, dispatch);\n            },\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            history(this.options),\n        ];\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-z': () => this.editor.commands.undo(),\n            'Shift-Mod-z': () => this.editor.commands.redo(),\n            'Mod-y': () => this.editor.commands.redo(),\n            // Russian keyboard layouts\n            'Mod-я': () => this.editor.commands.undo(),\n            'Shift-Mod-я': () => this.editor.commands.redo(),\n        };\n    },\n});\n\nexport { History, History as default };\n//# sourceMappingURL=index.js.map\n","<!--\n  - SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors\n  - SPDX-License-Identifier: AGPL-3.0-or-later\n-->\n\n<template>\n\t<Wrapper\n\t\t:content-loaded=\"true\"\n\t\t:show-outline-outside=\"showOutlineOutside\"\n\t\t@outline-toggled=\"outlineToggled\">\n\t\t<MainContainer>\n\t\t\t<template v-if=\"showMenuBar\">\n\t\t\t\t<MenuBar v-if=\"!readOnly\" :autohide=\"false\" />\n\t\t\t\t<slot v-else name=\"readonlyBar\">\n\t\t\t\t\t<ReadonlyBar />\n\t\t\t\t</slot>\n\t\t\t</template>\n\t\t\t<ContentContainer :read-only=\"readOnly\" />\n\t\t</MainContainer>\n\t</Wrapper>\n</template>\n\n<script>\nimport { Editor } from '@tiptap/core'\nimport MenuBar from '../Menu/MenuBar.vue'\nimport MainContainer from './MainContainer.vue'\nimport Wrapper from './Wrapper.vue'\n/* eslint-disable import/no-named-as-default */\nimport { getCurrentUser } from '@nextcloud/auth'\nimport History from '@tiptap/extension-history'\nimport { provide, watch } from 'vue'\nimport { provideEditor } from '../../composables/useEditor.ts'\nimport { editorFlagsKey } from '../../composables/useEditorFlags.ts'\nimport { useEditorMethods } from '../../composables/useEditorMethods.ts'\nimport { FocusTrap, RichText } from '../../extensions/index.js'\nimport { createMarkdownSerializer } from '../../extensions/Markdown.js'\nimport AttachmentResolver from '../../services/AttachmentResolver.js'\nimport { ATTACHMENT_RESOLVER } from '../Editor.provider.ts'\nimport ReadonlyBar from '../Menu/ReadonlyBar.vue'\nimport ContentContainer from './ContentContainer.vue'\n\nexport default {\n\tname: 'MarkdownContentEditor',\n\tcomponents: { ContentContainer, ReadonlyBar, MenuBar, MainContainer, Wrapper },\n\tprovide() {\n\t\tconst val = {}\n\n\t\tObject.defineProperties(val, {\n\t\t\t[ATTACHMENT_RESOLVER]: {\n\t\t\t\tget: () => this.$attachmentResolver ?? null,\n\t\t\t},\n\t\t})\n\n\t\treturn val\n\t},\n\n\tprops: {\n\t\tfileId: {\n\t\t\ttype: Number,\n\t\t\tdefault: null,\n\t\t},\n\t\tcontent: {\n\t\t\ttype: String,\n\t\t\trequired: true,\n\t\t},\n\t\treadOnly: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false,\n\t\t},\n\t\trelativePath: {\n\t\t\ttype: String,\n\t\t\tdefault: '',\n\t\t},\n\t\tshareToken: {\n\t\t\ttype: String,\n\t\t\tdefault: null,\n\t\t},\n\t\tshowMenuBar: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true,\n\t\t},\n\t\tshowOutlineOutside: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false,\n\t\t},\n\t},\n\temits: ['update:content'],\n\n\tsetup(props) {\n\t\tconst extensions = [\n\t\t\tRichText.configure({\n\t\t\t\textensions: [History],\n\t\t\t}),\n\t\t\tFocusTrap,\n\t\t]\n\t\tconst editor = new Editor({ extensions })\n\n\t\tconst { setEditable, setContent } = useEditorMethods(editor)\n\t\twatch(\n\t\t\t() => props.content,\n\t\t\t(content) => {\n\t\t\t\tsetContent(content)\n\t\t\t},\n\t\t)\n\n\t\tsetEditable(!props.readOnly)\n\t\twatch(\n\t\t\t() => props.readOnly,\n\t\t\t(readOnly) => {\n\t\t\t\tsetEditable(!readOnly)\n\t\t\t},\n\t\t)\n\n\t\tprovideEditor(editor)\n\t\tprovide(editorFlagsKey, {\n\t\t\tisPublic: false,\n\t\t\tisRichEditor: true,\n\t\t\tisRichWorkspace: false,\n\t\t})\n\t\treturn { editor, setContent }\n\t},\n\n\tcreated() {\n\t\t// Set content after the setup function\n\t\t// as it may render other vue components such as preview toggle\n\t\t// which breaks the context of the setup function.\n\t\tthis.setContent(this.content, { addToHistory: false })\n\t\tthis.editor.on('create', () => {\n\t\t\tthis.$emit('ready')\n\t\t\tthis.$parent.$emit('ready')\n\t\t})\n\t\tthis.editor.on('update', ({ editor }) => {\n\t\t\tconst markdown = createMarkdownSerializer(editor.schema).serialize(\n\t\t\t\teditor.state.doc,\n\t\t\t)\n\t\t\tthis.emit('update:content', {\n\t\t\t\tjson: editor.state.doc,\n\t\t\t\tmarkdown,\n\t\t\t})\n\t\t})\n\t\tif (this.fileId) {\n\t\t\tthis.$attachmentResolver = new AttachmentResolver({\n\t\t\t\tcurrentDirectory: this.relativePath?.match(/.*\\//),\n\t\t\t\tuser: getCurrentUser(),\n\t\t\t\tshareToken: this.shareToken,\n\t\t\t\tfileId: this.fileId,\n\t\t\t})\n\t\t}\n\t},\n\n\tbeforeDestroy() {\n\t\tthis.editor.destroy()\n\t},\n\n\tmethods: {\n\t\toutlineToggled(visible) {\n\t\t\tthis.emit('outline-toggled', visible)\n\t\t},\n\n\t\t/**\n\t\t * Wrapper to emit events on our own and the parent component\n\t\t *\n\t\t * The parent might be either the root component of src/editor.js or Viewer.vue which collectives currently uses\n\t\t *\n\t\t * Ideally this would be done in a generic way in the src/editor.js API abstraction, but it seems\n\t\t * that there is no proper way to pass any received event along in vue, the only option I've found\n\t\t * in https://github.com/vuejs/vue/issues/230 feels too hacky to me, so we just emit twice for now\n\t\t *\n\t\t * @param {string} event The event name\n\t\t * @param {any} data The data to pass along\n\t\t */\n\t\temit(event, data) {\n\t\t\tthis.$emit(event, data)\n\t\t\tthis.$parent?.$emit(event, data)\n\t\t},\n\t},\n}\n</script>\n\n<style lang=\"scss\">\n@import './../../css/prosemirror';\n@import './../../css/print';\n</style>\n"],"names":["GOOD_LEAF_SIZE","RopeSequence","other","Append","from","to","i","f","result","elt","values","Leaf","prototypeAccessors","start","left","right","leftLen","inner","ropeSequence","max_empty_items","Branch","items","eventCount","state","preserveItems","end","remap","mapFrom","transform","selection","remaining","addAfter","addBefore","item","Item","step","map","histOptions","newItems","oldItems","lastItem","merged","overflow","DEPTH_OVERFLOW","cutOffEvents","maps","Mapping","mirrorPos","array","rebasedTransform","rebasedCount","rebasedItems","mapping","newUntil","iRebased","pos","newMaps","branch","count","upto","events","newItem","last","n","cutPoint","mirrorOffset","HistoryState","done","undone","prevRanges","prevTime","prevComposition","applyTransaction","history","tr","options","historyTr","historyKey","rebased","closeHistoryKey","appended","mustPreserveItems","rangesFor","composition","newGroup","isAdjacentTo","mapRanges","adjacent","_from","_to","ranges","histTransaction","redo","pop","added","newHist","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","PluginKey","config","Plugin","hist","view","e","inputType","command","undo","buildCommand","scroll","dispatch","History","Extension","_sfc_main","ContentContainer","ReadonlyBar","MenuBar","MainContainer","Wrapper","val","ATTACHMENT_RESOLVER","props","extensions","RichText","FocusTrap","editor","Editor","setEditable","setContent","useEditorMethods","watch","content","readOnly","provideEditor","provide","editorFlagsKey","markdown","createMarkdownSerializer","AttachmentResolver","getCurrentUser","visible","event","data"],"mappings":"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","x_google_ignoreList":[0,1,2]}