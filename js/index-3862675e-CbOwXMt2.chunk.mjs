import{q as E,G as M}from"./graph-Ckxqai6h.chunk.mjs";import{m as J,l as q}from"./layout-BJJsvxxV.chunk.mjs";import{c as A}from"./clone-CyGWkQVk.chunk.mjs";import{i as H,u as W,s as z,a as K,b as Q,g as D,p as O,c as U,d as V,e as Y,f as Z,h as G,j as T}from"./edges-e0da2a9e-RRdRrNZD.chunk.mjs";import{l as i,c as B,q as C,h as I}from"./mermaid.core-DIdKAxpj.chunk.mjs";import{c as _}from"./createText-2e5e7dd3-1-jF1Jg9.chunk.mjs";function y(n){var e={options:{directed:n.isDirected(),multigraph:n.isMultigraph(),compound:n.isCompound()},nodes:ee(n),edges:te(n)};return E(n.graph())||(e.value=A(n.graph())),e}function ee(n){return J(n.nodes(),function(e){var t=n.node(e),a=n.parent(e),r={v:e};return E(t)||(r.value=t),E(a)||(r.parent=a),r})}function te(n){return J(n.edges(),function(e){var t=n.edge(e),a={v:e.v,w:e.w};return E(e.name)||(a.name=e.name),E(t)||(a.value=t),a})}let l={},u={},R={};const ne=()=>{u={},R={},l={}},S=(n,e)=>(i.trace("In isDescendant",e," ",n," = ",u[e].includes(n)),!!u[e].includes(n)),re=(n,e)=>(i.info("Descendants of ",e," is ",u[e]),i.info("Edge is ",n),n.v===e||n.w===e?!1:u[e]?u[e].includes(n.v)||S(n.v,e)||S(n.w,e)||u[e].includes(n.w):(i.debug("Tilt, ",e,",not in descendants"),!1)),L=(n,e,t,a)=>{i.warn("Copying children of ",n,"root",a,"data",e.node(n),a);const r=e.children(n)||[];n!==a&&r.push(n),i.warn("Copying (nodes) clusterId",n,"nodes",r),r.forEach(o=>{if(e.children(o).length>0)L(o,e,t,a);else{const c=e.node(o);i.info("cp ",o," to ",a," with parent ",n),t.setNode(o,c),a!==e.parent(o)&&(i.warn("Setting parent",o,e.parent(o)),t.setParent(o,e.parent(o))),n!==a&&o!==n?(i.debug("Setting parent",o,n),t.setParent(o,n)):(i.info("In copy ",n,"root",a,"data",e.node(n),a),i.debug("Not Setting parent for node=",o,"cluster!==rootId",n!==a,"node!==clusterId",o!==n));const g=e.edges(o);i.debug("Copying Edges",g),g.forEach(h=>{i.info("Edge",h);const f=e.edge(h.v,h.w,h.name);i.info("Edge data",f,a);try{re(h,a)?(i.info("Copying as ",h.v,h.w,f,h.name),t.setEdge(h.v,h.w,f,h.name),i.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):i.info("Skipping copy of edge ",h.v,"-->",h.w," rootId: ",a," clusterId:",n)}catch(w){i.error(w)}})}i.debug("Removing node",o),e.removeNode(o)})},k=(n,e)=>{const t=e.children(n);let a=[...t];for(const r of t)R[r]=n,a=[...a,...k(r,e)];return a},N=(n,e)=>{i.trace("Searching",n);const t=e.children(n);if(i.trace("Searching children of id ",n,t),t.length<1)return i.trace("This is a valid node",n),n;for(const a of t){const r=N(a,e);if(r)return i.trace("Found replacement for",n," => ",r),r}},X=n=>!l[n]||!l[n].externalConnections?n:l[n]?l[n].id:n,ie=(n,e)=>{if(!n||e>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");n.nodes().forEach(function(t){n.children(t).length>0&&(i.warn("Cluster identified",t," Replacement id in edges: ",N(t,n)),u[t]=k(t,n),l[t]={id:N(t,n),clusterData:n.node(t)})}),n.nodes().forEach(function(t){const a=n.children(t),r=n.edges();a.length>0?(i.debug("Cluster identified",t,u),r.forEach(o=>{if(o.v!==t&&o.w!==t){const c=S(o.v,t),g=S(o.w,t);c^g&&(i.warn("Edge: ",o," leaves cluster ",t),i.warn("Descendants of XXX ",t,": ",u[t]),l[t].externalConnections=!0)}})):i.debug("Not a cluster ",t,u)});for(let t of Object.keys(l)){const a=l[t].id,r=n.parent(a);r!==t&&l[r]&&!l[r].externalConnections&&(l[t].id=r)}n.edges().forEach(function(t){const a=n.edge(t);i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(n.edge(t)));let r=t.v,o=t.w;if(i.warn("Fix XXX",l,"ids:",t.v,t.w,"Translating: ",l[t.v]," --- ",l[t.w]),l[t.v]&&l[t.w]&&l[t.v]===l[t.w]){i.warn("Fixing and trixing link to self - removing XXX",t.v,t.w,t.name),i.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),r=X(t.v),o=X(t.w),n.removeEdge(t.v,t.w,t.name);const c=t.w+"---"+t.v;n.setNode(c,{domId:c,id:c,labelStyle:"",labelText:a.label,padding:0,shape:"labelRect",style:""});const g=structuredClone(a),h=structuredClone(a);g.label="",g.arrowTypeEnd="none",h.label="",g.fromCluster=t.v,h.toCluster=t.v,n.setEdge(r,c,g,t.name+"-cyclic-special"),n.setEdge(c,o,h,t.name+"-cyclic-special")}else if(l[t.v]||l[t.w]){if(i.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),r=X(t.v),o=X(t.w),n.removeEdge(t.v,t.w,t.name),r!==t.v){const c=n.parent(r);l[c].externalConnections=!0,a.fromCluster=t.v}if(o!==t.w){const c=n.parent(o);l[c].externalConnections=!0,a.toCluster=t.w}i.warn("Fix Replacing with XXX",r,o,t.name),n.setEdge(r,o,a,t.name)}}),i.warn("Adjusted Graph",y(n)),F(n,0),i.trace(l)},F=(n,e)=>{if(i.warn("extractor - ",e,y(n),n.children("D")),e>10){i.error("Bailing out");return}let t=n.nodes(),a=!1;for(const r of t){const o=n.children(r);a=a||o.length>0}if(!a){i.debug("Done, no node has children",n.nodes());return}i.debug("Nodes = ",t,e);for(const r of t)if(i.debug("Extracting node",r,l,l[r]&&!l[r].externalConnections,!n.parent(r),n.node(r),n.children("D")," Depth ",e),!l[r])i.debug("Not a cluster",r,e);else if(!l[r].externalConnections&&n.children(r)&&n.children(r).length>0){i.warn("Cluster without external connections, without a parent and with children",r,e);let o=n.graph().rankdir==="TB"?"LR":"TB";l[r]&&l[r].clusterData&&l[r].clusterData.dir&&(o=l[r].clusterData.dir,i.warn("Fixing dir",l[r].clusterData.dir,o));const c=new M({multigraph:!0,compound:!0}).setGraph({rankdir:o,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",y(n)),L(r,n,c,r),n.setNode(r,{clusterNode:!0,id:r,clusterData:l[r].clusterData,labelText:l[r].labelText,graph:c}),i.warn("New graph after copy node: (",r,")",y(c)),i.debug("Old graph after copy",y(n))}else i.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!l[r].externalConnections," no parent: ",!n.parent(r)," children ",n.children(r)&&n.children(r).length>0,n.children("D"),e),i.debug(l);t=n.nodes(),i.warn("New list of nodes",t);for(const r of t){const o=n.node(r);i.warn(" Now next level",r,o),o.clusterNode&&F(o.graph,e+1)}},P=(n,e)=>{if(e.length===0)return[];let t=Object.assign(e);return e.forEach(a=>{const r=n.children(a),o=P(n,r);t=[...t,...o]}),t},ae=n=>P(n,n.children()),oe=(n,e)=>{i.info("Creating subgraph rect for ",e.id,e);const t=B(),a=n.insert("g").attr("class","cluster"+(e.class?" "+e.class:"")).attr("id",e.id),r=a.insert("rect",":first-child"),o=C(t.flowchart.htmlLabels),c=a.insert("g").attr("class","cluster-label"),g=e.labelType==="markdown"?_(c,e.labelText,{style:e.labelStyle,useHtmlLabels:o}):c.node().appendChild(G(e.labelText,e.labelStyle,void 0,!0));let h=g.getBBox();if(C(t.flowchart.htmlLabels)){const d=g.children[0],s=I(g);h=d.getBoundingClientRect(),s.attr("width",h.width),s.attr("height",h.height)}const f=0*e.padding,w=f/2,p=e.width<=h.width+f?h.width+f:e.width;e.width<=h.width+f?e.diff=(h.width-e.width)/2-e.padding/2:e.diff=-e.padding/2,i.trace("Data ",e,JSON.stringify(e)),r.attr("style",e.style).attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-p/2).attr("y",e.y-e.height/2-w).attr("width",p).attr("height",e.height+f);const{subGraphTitleTopMargin:x}=D(t);o?c.attr("transform","translate(".concat(e.x-h.width/2,", ").concat(e.y-e.height/2+x,")")):c.attr("transform","translate(".concat(e.x,", ").concat(e.y-e.height/2+x,")"));const v=r.node().getBBox();return e.width=v.width,e.height=v.height,e.intersect=function(d){return T(e,d)},a},de=(n,e)=>{const t=n.insert("g").attr("class","note-cluster").attr("id",e.id),a=t.insert("rect",":first-child"),r=0*e.padding,o=r/2;a.attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-e.width/2-o).attr("y",e.y-e.height/2-o).attr("width",e.width+r).attr("height",e.height+r).attr("fill","none");const c=a.node().getBBox();return e.width=c.width,e.height=c.height,e.intersect=function(g){return T(e,g)},t},se=(n,e)=>{const t=B(),a=n.insert("g").attr("class",e.classes).attr("id",e.id),r=a.insert("rect",":first-child"),o=a.insert("g").attr("class","cluster-label"),c=a.append("rect"),g=o.node().appendChild(G(e.labelText,e.labelStyle,void 0,!0));let h=g.getBBox();if(C(t.flowchart.htmlLabels)){const d=g.children[0],s=I(g);h=d.getBoundingClientRect(),s.attr("width",h.width),s.attr("height",h.height)}h=g.getBBox();const f=0*e.padding,w=f/2,p=e.width<=h.width+e.padding?h.width+e.padding:e.width;e.width<=h.width+e.padding?e.diff=(h.width+e.padding*0-e.width)/2:e.diff=-e.padding/2,r.attr("class","outer").attr("x",e.x-p/2-w).attr("y",e.y-e.height/2-w).attr("width",p+f).attr("height",e.height+f),c.attr("class","inner").attr("x",e.x-p/2-w).attr("y",e.y-e.height/2-w+h.height-1).attr("width",p+f).attr("height",e.height+f-h.height-3);const{subGraphTitleTopMargin:x}=D(t);o.attr("transform","translate(".concat(e.x-h.width/2,", ").concat(e.y-e.height/2-e.padding/3+(C(t.flowchart.htmlLabels)?5:3)+x,")"));const v=r.node().getBBox();return e.height=v.height,e.intersect=function(d){return T(e,d)},a},le=(n,e)=>{const t=n.insert("g").attr("class",e.classes).attr("id",e.id),a=t.insert("rect",":first-child"),r=0*e.padding,o=r/2;a.attr("class","divider").attr("x",e.x-e.width/2-o).attr("y",e.y-e.height/2).attr("width",e.width+r).attr("height",e.height+r);const c=a.node().getBBox();return e.width=c.width,e.height=c.height,e.diff=-e.padding/2,e.intersect=function(g){return T(e,g)},t},he={rect:oe,roundedWithTitle:se,noteGroup:de,divider:le};let $={};const ce=(n,e)=>{i.trace("Inserting cluster");const t=e.shape||"rect";$[e.id]=he[t](n,e)},ge=()=>{$={}},j=async(n,e,t,a,r,o)=>{i.info("Graph in recursive render: XXX",y(e),r);const c=e.graph().rankdir;i.trace("Dir in recursive render - dir:",c);const g=n.insert("g").attr("class","root");e.nodes()?i.info("Recursive render XXX",e.nodes()):i.info("No nodes found for",e),e.edges().length>0&&i.trace("Recursive edges",e.edge(e.edges()[0]));const h=g.insert("g").attr("class","clusters"),f=g.insert("g").attr("class","edgePaths"),w=g.insert("g").attr("class","edgeLabels"),p=g.insert("g").attr("class","nodes");await Promise.all(e.nodes().map(async function(d){const s=e.node(d);if(r!==void 0){const m=JSON.parse(JSON.stringify(r.clusterData));i.info("Setting data for cluster XXX (",d,") ",m,r),e.setNode(r.id,m),e.parent(d)||(i.trace("Setting parent",d,r.id),e.setParent(d,r.id,m))}if(i.info("(Insert) Node XXX"+d+": "+JSON.stringify(e.node(d))),s&&s.clusterNode){i.info("Cluster identified",d,s.width,e.node(d));const m=await j(p,s.graph,t,a,e.node(d),o),b=m.elem;W(s,b),s.diff=m.diff||0,i.info("Node bounds (abc123)",d,s,s.width,s.x,s.y),z(b,s),i.warn("Recursive render complete ",b,s)}else e.children(d).length>0?(i.info("Cluster - the non recursive path XXX",d,s.id,s,e),i.info(N(s.id,e)),l[s.id]={id:N(s.id,e),node:s}):(i.info("Node - the non recursive path",d,s.id,s),await K(p,e.node(d),c))})),e.edges().forEach(function(d){const s=e.edge(d.v,d.w,d.name);i.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(d)),i.info("Edge "+d.v+" -> "+d.w+": ",d," ",JSON.stringify(e.edge(d))),i.info("Fix",l,"ids:",d.v,d.w,"Translating: ",l[d.v],l[d.w]),Q(w,s)}),e.edges().forEach(function(d){i.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(d))}),i.info("#############################################"),i.info("###                Layout                 ###"),i.info("#############################################"),i.info(e),q(e),i.info("Graph after layout:",y(e));let x=0;const{subGraphTitleTotalMargin:v}=D(o);return ae(e).forEach(function(d){const s=e.node(d);i.info("Position "+d+": "+JSON.stringify(e.node(d))),i.info("Position "+d+": ("+s.x,","+s.y,") width: ",s.width," height: ",s.height),s&&s.clusterNode?(s.y+=v,O(s)):e.children(d).length>0?(s.height+=v,ce(h,s),l[s.id].node=s):(s.y+=v/2,O(s))}),e.edges().forEach(function(d){const s=e.edge(d);i.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(s),s),s.points.forEach(b=>b.y+=v/2);const m=U(f,d,s,l,t,e,a);V(s,m)}),e.nodes().forEach(function(d){const s=e.node(d);i.info(d,s.type,s.diff),s.type==="group"&&(x=s.diff)}),{elem:g,diff:x}},me=async(n,e,t,a,r)=>{H(n,t,a,r),Y(),Z(),ge(),ne(),i.warn("Graph at first:",JSON.stringify(y(e))),ie(e),i.warn("Graph after:",JSON.stringify(y(e)));const o=B();await j(n,e,a,r,void 0,o)};export{me as r};
