const f=Math.PI,M=2*f,p=1e-6,A=M-p;function T(n){this._+=n[0];for(let t=1,s=n.length;t<s;++t)this._+=arguments[t]+n[t]}function E(n){let t=Math.floor(n);if(!(t>=0))throw new Error(`invalid digits: ${n}`);if(t>15)return T;const s=10**t;return function(h){this._+=h[0];for(let i=1,_=h.length;i<_;++i)this._+=Math.round(arguments[i]*s)/s+h[i]}}class L{constructor(t){this._x0=this._y0=this._x1=this._y1=null,this._="",this._append=t==null?T:E(t)}moveTo(t,s){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+s}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._append`Z`)}lineTo(t,s){this._append`L${this._x1=+t},${this._y1=+s}`}quadraticCurveTo(t,s,h,i){this._append`Q${+t},${+s},${this._x1=+h},${this._y1=+i}`}bezierCurveTo(t,s,h,i,_,r){this._append`C${+t},${+s},${+h},${+i},${this._x1=+_},${this._y1=+r}`}arcTo(t,s,h,i,_){if(t=+t,s=+s,h=+h,i=+i,_=+_,_<0)throw new Error(`negative radius: ${_}`);let r=this._x1,u=this._y1,l=h-t,$=i-s,e=r-t,o=u-s,a=e*e+o*o;if(this._x1===null)this._append`M${this._x1=t},${this._y1=s}`;else if(a>p)if(!(Math.abs(o*l-$*e)>p)||!_)this._append`L${this._x1=t},${this._y1=s}`;else{let d=h-r,x=i-u,y=l*l+$*$,m=d*d+x*x,g=Math.sqrt(y),w=Math.sqrt(a),v=_*Math.tan((f-Math.acos((y+a-m)/(2*g*w)))/2),c=v/w,b=v/g;Math.abs(c-1)>p&&this._append`L${t+c*e},${s+c*o}`,this._append`A${_},${_},0,0,${+(o*d>e*x)},${this._x1=t+b*l},${this._y1=s+b*$}`}}arc(t,s,h,i,_,r){if(t=+t,s=+s,h=+h,r=!!r,h<0)throw new Error(`negative radius: ${h}`);let u=h*Math.cos(i),l=h*Math.sin(i),$=t+u,e=s+l,o=1^r,a=r?i-_:_-i;this._x1===null?this._append`M${$},${e}`:(Math.abs(this._x1-$)>p||Math.abs(this._y1-e)>p)&&this._append`L${$},${e}`,h&&(a<0&&(a=a%M+M),a>A?this._append`A${h},${h},0,1,${o},${t-u},${s-l}A${h},${h},0,1,${o},${this._x1=$},${this._y1=e}`:a>p&&this._append`A${h},${h},0,${+(a>=f)},${o},${this._x1=t+h*Math.cos(_)},${this._y1=s+h*Math.sin(_)}`)}rect(t,s,h,i){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+s}h${h=+h}v${+i}h${-h}Z`}toString(){return this._}}function q(n){return function(){return n}}function C(n){let t=3;return n.digits=function(s){if(!arguments.length)return t;if(s==null)t=null;else{const h=Math.floor(s);if(!(h>=0))throw new RangeError(`invalid digits: ${s}`);t=h}return n},()=>new L(t)}export{q as c,C as w};
