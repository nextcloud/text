import{_ as u,av as F,aw as L,ax as M,ay as Y,l as a,d as j,az as H,aA as z,ah as _,am as q,ai as D,ag as K,aB as Q,aC as U,aD as V}from"./mermaid.core-Dwh8_YBE.chunk.mjs";import{G}from"./graph-C1wDGKNm.chunk.mjs";import{l as W}from"./layout-iAXqagCu.chunk.mjs";import{i as b}from"./_baseUniq-DZZ0eotL.chunk.mjs";import{c as Z}from"./clone-c1v30_BS.chunk.mjs";import{m as k}from"./_basePickBy-DPMChfI5.chunk.mjs";import"./modulepreload-polyfill-B3hybnpm.chunk.mjs";import"./emoji-picker-KVqjnXYv.chunk.mjs";import"./NcNoteCard-C6xb7vi0-DT19luaD.chunk.mjs";import"./index-DfiDB3im.chunk.mjs";import"./vue.runtime.esm-Cd-BRs9x.chunk.mjs";function w(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:$(e),edges:ee(e)};return b(e.graph())||(r.value=Z(e.graph())),r}function $(e){return k(e.nodes(),function(r){var n=e.node(r),s=e.parent(r),i={v:r};return b(n)||(i.value=n),b(s)||(i.parent=s),i})}function ee(e){return k(e.edges(),function(r){var n=e.edge(r),s={v:r.v,w:r.w};return b(r.name)||(s.name=r.name),b(n)||(s.value=n),s})}var o=new Map,X=new Map,B=new Map,ne=u(()=>{X.clear(),B.clear(),o.clear()},"clear"),I=u((e,r)=>{const n=X.get(r)||[];return a.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),re=u((e,r)=>{const n=X.get(r)||[];return a.info("Descendants of ",r," is ",n),a.info("Edge is ",e),e.v===r||e.w===r?!1:n?n.includes(e.v)||I(e.v,r)||I(e.w,r)||n.includes(e.w):(a.debug("Tilt, ",r,",not in descendants"),!1)},"edgeInCluster"),P=u((e,r,n,s)=>{a.warn("Copying children of ",e,"root",s,"data",r.node(e),s);const i=r.children(e)||[];e!==s&&i.push(e),a.warn("Copying (nodes) clusterId",e,"nodes",i),i.forEach(d=>{if(r.children(d).length>0)P(d,r,n,s);else{const c=r.node(d);a.info("cp ",d," to ",s," with parent ",e),n.setNode(d,c),s!==r.parent(d)&&(a.warn("Setting parent",d,r.parent(d)),n.setParent(d,r.parent(d))),e!==s&&d!==e?(a.debug("Setting parent",d,e),n.setParent(d,e)):(a.info("In copy ",e,"root",s,"data",r.node(e),s),a.debug("Not Setting parent for node=",d,"cluster!==rootId",e!==s,"node!==clusterId",d!==e));const g=r.edges(d);a.debug("Copying Edges",g),g.forEach(p=>{a.info("Edge",p);const f=r.edge(p.v,p.w,p.name);a.info("Edge data",f,s);try{re(p,s)?(a.info("Copying as ",p.v,p.w,f,p.name),n.setEdge(p.v,p.w,f,p.name),a.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):a.info("Skipping copy of edge ",p.v,"-->",p.w," rootId: ",s," clusterId:",e)}catch(m){a.error(m)}})}a.debug("Removing node",d),r.removeNode(d)})},"copy"),A=u((e,r)=>{const n=r.children(e);let s=[...n];for(const i of n)B.set(i,e),s=[...s,...A(i,r)];return s},"extractDescendants"),te=u((e,r,n)=>{const s=e.edges().filter(g=>g.v===r||g.w===r),i=e.edges().filter(g=>g.v===n||g.w===n),d=s.map(g=>({v:g.v===r?n:g.v,w:g.w===r?r:g.w})),c=i.map(g=>({v:g.v,w:g.w}));return d.filter(g=>c.some(p=>g.v===p.v&&g.w===p.w))},"findCommonEdges"),C=u((e,r,n)=>{const s=r.children(e);if(a.trace("Searching children of id ",e,s),s.length<1)return e;let i;for(const d of s){const c=C(d,r,n),g=te(r,n,c);if(c)if(g.length>0)i=c;else return c}return i},"findNonClusterChild"),O=u(e=>!o.has(e)||!o.get(e).externalConnections?e:o.has(e)?o.get(e).id:e,"getAnchorId"),ae=u((e,r)=>{if(!e||r>10){a.debug("Opting out, no graph ");return}else a.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(a.warn("Cluster identified",n," Replacement id in edges: ",C(n,e,n)),X.set(n,A(n,e)),o.set(n,{id:C(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const s=e.children(n),i=e.edges();s.length>0?(a.debug("Cluster identified",n,X),i.forEach(d=>{const c=I(d.v,n),g=I(d.w,n);c^g&&(a.warn("Edge: ",d," leaves cluster ",n),a.warn("Descendants of XXX ",n,": ",X.get(n)),o.get(n).externalConnections=!0)})):a.debug("Not a cluster ",n,X)});for(let n of o.keys()){const s=o.get(n).id,i=e.parent(s);i!==n&&o.has(i)&&!o.get(i).externalConnections&&(o.get(n).id=i)}e.edges().forEach(function(n){const s=e.edge(n);a.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),a.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let i=n.v,d=n.w;if(a.warn("Fix XXX",o,"ids:",n.v,n.w,"Translating: ",o.get(n.v)," --- ",o.get(n.w)),o.get(n.v)||o.get(n.w)){if(a.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),i=O(n.v),d=O(n.w),e.removeEdge(n.v,n.w,n.name),i!==n.v){const c=e.parent(i);o.get(c).externalConnections=!0,s.fromCluster=n.v}if(d!==n.w){const c=e.parent(d);o.get(c).externalConnections=!0,s.toCluster=n.w}a.warn("Fix Replacing with XXX",i,d,n.name),e.setEdge(i,d,s,n.name)}}),a.warn("Adjusted Graph",w(e)),J(e,0),a.trace(o)},"adjustClustersAndEdges"),J=u((e,r)=>{if(a.warn("extractor - ",r,w(e),e.children("D")),r>10){a.error("Bailing out");return}let n=e.nodes(),s=!1;for(const i of n){const d=e.children(i);s=s||d.length>0}if(!s){a.debug("Done, no node has children",e.nodes());return}a.debug("Nodes = ",n,r);for(const i of n)if(a.debug("Extracting node",i,o,o.has(i)&&!o.get(i).externalConnections,!e.parent(i),e.node(i),e.children("D")," Depth ",r),!o.has(i))a.debug("Not a cluster",i,r);else if(!o.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){a.warn("Cluster without external connections, without a parent and with children",i,r);let d=e.graph().rankdir==="TB"?"LR":"TB";o.get(i)?.clusterData?.dir&&(d=o.get(i).clusterData.dir,a.warn("Fixing dir",o.get(i).clusterData.dir,d));const c=new G({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});a.warn("Old graph before copy",w(e)),P(i,e,c,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:o.get(i).clusterData,label:o.get(i).label,graph:c}),a.warn("New graph after copy node: (",i,")",w(c)),a.debug("Old graph after copy",w(e))}else a.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!o.get(i).externalConnections," no parent: ",!e.parent(i)," children ",e.children(i)&&e.children(i).length>0,e.children("D"),r),a.debug(o);n=e.nodes(),a.warn("New list of nodes",n);for(const i of n){const d=e.node(i);a.warn(" Now next level",i,d),d?.clusterNode&&J(d.graph,r+1)}},"extractor"),R=u((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(s=>{const i=e.children(s),d=R(e,i);n=[...n,...d]}),n},"sorter"),ie=u(e=>R(e,e.children()),"sortNodesByHierarchy"),T=u(async(e,r,n,s,i,d)=>{a.warn("Graph in recursive render:XAX",w(r),i);const c=r.graph().rankdir;a.trace("Dir in recursive render - dir:",c);const g=e.insert("g").attr("class","root");r.nodes()?a.info("Recursive render XXX",r.nodes()):a.info("No nodes found for",r),r.edges().length>0&&a.info("Recursive edges",r.edge(r.edges()[0]));const p=g.insert("g").attr("class","clusters"),f=g.insert("g").attr("class","edgePaths"),m=g.insert("g").attr("class","edgeLabels"),y=g.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(l){const t=r.node(l);if(i!==void 0){const h=JSON.parse(JSON.stringify(i.clusterData));a.trace(`Setting data for parent cluster XXX
 Node.id = `,l,`
 data=`,h.height,`
Parent cluster`,i.height),r.setNode(i.id,h),r.parent(l)||(a.trace("Setting parent",l,i.id),r.setParent(l,i.id,h))}if(a.info("(Insert) Node XXX"+l+": "+JSON.stringify(r.node(l))),t?.clusterNode){a.info("Cluster identified XBX",l,t.width,r.node(l));const{ranksep:h,nodesep:E}=r.graph();t.graph.setGraph({...t.graph.graph(),ranksep:h+25,nodesep:E});const N=await T(y,t.graph,n,s,r.node(l),d),S=N.elem;H(t,S),t.diff=N.diff||0,a.info("New compound node after recursive render XAX",l,"width",t.width,"height",t.height),z(S,t)}else r.children(l).length>0?(a.trace("Cluster - the non recursive path XBX",l,t.id,t,t.width,"Graph:",r),a.trace(C(t.id,r)),o.set(t.id,{id:C(t.id,r),node:t})):(a.trace("Node - the non recursive path XAX",l,y,r.node(l),c),await _(y,r.node(l),{config:d,dir:c}))})),await u(async()=>{const l=r.edges().map(async function(t){const h=r.edge(t.v,t.w,t.name);a.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),a.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(r.edge(t))),a.info("Fix",o,"ids:",t.v,t.w,"Translating: ",o.get(t.v),o.get(t.w)),await V(m,h)});await Promise.all(l)},"processEdges")(),a.info("Graph before layout:",JSON.stringify(w(r))),a.info("############################################# XXX"),a.info("###                Layout                 ### XXX"),a.info("############################################# XXX"),W(r),a.info("Graph after layout:",JSON.stringify(w(r)));let v=0,{subGraphTitleTotalMargin:x}=q(d);return await Promise.all(ie(r).map(async function(l){const t=r.node(l);if(a.info("Position XBX => "+l+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t?.clusterNode)t.y+=x,a.info("A tainted cluster node XBX1",l,t.id,t.width,t.height,t.x,t.y,r.parent(l)),o.get(t.id).node=t,D(t);else if(r.children(l).length>0){a.info("A pure cluster node XBX1",l,t.id,t.x,t.y,t.width,t.height,r.parent(l)),t.height+=x,r.node(t.parentId);const h=t?.padding/2||0,E=t?.labelBBox?.height||0,N=E-h||0;a.debug("OffsetY",N,"labelHeight",E,"halfPadding",h),await K(p,t),o.get(t.id).node=t}else{const h=r.node(t.parentId);t.y+=x/2,a.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",h,h?.offsetY,t),D(t)}})),r.edges().forEach(function(l){const t=r.edge(l);a.info("Edge "+l.v+" -> "+l.w+": "+JSON.stringify(t),t),t.points.forEach(S=>S.y+=x/2);const h=r.node(l.v);var E=r.node(l.w);const N=Q(f,t,o,n,h,E,s);U(t,N)}),r.nodes().forEach(function(l){const t=r.node(l);a.info(l,t.type,t.diff),t.isGroup&&(v=t.diff)}),a.warn("Returning from recursive render XAX",g,v),{elem:g,diff:v}},"recursiveRender"),me=u(async(e,r)=>{const n=new G({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),s=r.select("g");F(s,e.markers,e.type,e.diagramId),L(),M(),Y(),ne(),e.nodes.forEach(d=>{n.setNode(d.id,{...d}),d.parentId&&n.setParent(d.id,d.parentId)}),a.debug("Edges:",e.edges),e.edges.forEach(d=>{if(d.start===d.end){const c=d.start,g=c+"---"+c+"---1",p=c+"---"+c+"---2",f=n.node(c);n.setNode(g,{domId:g,id:g,parentId:f.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(g,f.parentId),n.setNode(p,{domId:p,id:p,parentId:f.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(p,f.parentId);const m=structuredClone(d),y=structuredClone(d),v=structuredClone(d);m.label="",m.arrowTypeEnd="none",m.id=c+"-cyclic-special-1",y.arrowTypeEnd="none",y.id=c+"-cyclic-special-mid",v.label="",f.isGroup&&(m.fromCluster=c,v.toCluster=c),v.id=c+"-cyclic-special-2",n.setEdge(c,g,m,c+"-cyclic-special-0"),n.setEdge(g,p,y,c+"-cyclic-special-1"),n.setEdge(p,c,v,c+"-cyc<lic-special-2")}else n.setEdge(d.start,d.end,{...d},d.id)}),a.warn("Graph at first:",JSON.stringify(w(n))),ae(n),a.warn("Graph after XAX:",JSON.stringify(w(n)));const i=j();await T(s,n,e.type,e.diagramId,void 0,i)},"render");export{me as render};
